<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lrtwjhs&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lrtwjhs.github.io/"/>
  <updated>2020-12-24T14:30:25.765Z</updated>
  <id>https://lrtwjhs.github.io/</id>
  
  <author>
    <name>Rutao Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 26. Remove Duplicates from Sorted Array</title>
    <link href="https://lrtwjhs.github.io/2020/12/24/2020-12-24-leetcode-26/"/>
    <id>https://lrtwjhs.github.io/2020/12/24/2020-12-24-leetcode-26/</id>
    <published>2020-12-23T16:00:00.000Z</published>
    <updated>2020-12-24T14:30:25.765Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接:</strong><br><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="external">https://leetcode.com/problems/remove-duplicates-from-sorted-array/</a></p><p><strong>思路:</strong><br>使用快慢指针来记录遍历的坐标，最开始时两个指针都指向第一个数字，如果两个指针指的数字相同，则快指针向前走一步，如果不同，则两个指针都向前走一步，这样当快指针走完整个数组后，慢指针当前的坐标加1就是数组中不同数字的个数。</p><p><strong>Solution:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目链接:&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://leetcode.com/problems/remove-duplicates-from-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;htt
      
    
    </summary>
    
      <category term="算法" scheme="https://lrtwjhs.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://lrtwjhs.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode-Easy" scheme="https://lrtwjhs.github.io/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 20. Valid Parentheses</title>
    <link href="https://lrtwjhs.github.io/2020/12/24/2020-12-24-leetcode-20/"/>
    <id>https://lrtwjhs.github.io/2020/12/24/2020-12-24-leetcode-20/</id>
    <published>2020-12-23T16:00:00.000Z</published>
    <updated>2020-12-24T14:06:31.267Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接:</strong><br><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="external">https://leetcode.com/problems/valid-parentheses/</a></p><p><strong>思路:</strong><br>用一个栈，开始遍历输入字符串，如果当前字符为左半边括号时，则将其压入栈中，如果遇到右半边括号时，若此时栈为空，则直接返回 false，如不为空，则取出栈顶元素，若为对应的左半边括号，则继续循环，反之返回 false。</p><p><strong>Solution:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="comment">// 如果是左括号，则入栈</span></span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'('</span> || ch == <span class="string">'['</span> || ch == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是右括号，则比较其与栈顶元素是否配对</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ch == <span class="string">')'</span> &amp;&amp; stack.peek() != <span class="string">'('</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ch == <span class="string">']'</span> &amp;&amp; stack.peek() != <span class="string">'['</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ch == <span class="string">'&#125;'</span> &amp;&amp; stack.peek() != <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后栈为空则表示完全匹配完毕</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目链接:&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://leetcode.com/problems/valid-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://leetcode.com/
      
    
    </summary>
    
      <category term="算法" scheme="https://lrtwjhs.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://lrtwjhs.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode-Easy" scheme="https://lrtwjhs.github.io/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 21. Merge Two Sorted Lists</title>
    <link href="https://lrtwjhs.github.io/2020/12/24/2020-12-24-leetcode-21/"/>
    <id>https://lrtwjhs.github.io/2020/12/24/2020-12-24-leetcode-21/</id>
    <published>2020-12-23T16:00:00.000Z</published>
    <updated>2020-12-24T14:30:28.859Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接:</strong><br><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="external">https://leetcode.com/problems/merge-two-sorted-lists/</a></p><p><strong>思路:</strong><br>递归的写法，当某个链表为空了，就返回另一个。然后核心还是比较当前两个节点值大小，如果 l1 的小，那么对于 l1 的下一个节点和 l2 调用递归函数，将返回值赋值给 l1.next，然后返回 l1；否则就对于 l2 的下一个节点和 l1 调用递归函数，将返回值赋值给 l2.next，然后返回 l2。</p><p><strong>Solution:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode head = (l1.val &lt; l2.val) ? l1 : l2;</span><br><span class="line">        ListNode nonhead = (l1.val &lt; l2.val) ? l2 : l1;</span><br><span class="line">        head.next = mergeTwoLists(head.next, nonhead);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目链接:&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-two-sorted-lists/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://leetcode
      
    
    </summary>
    
      <category term="算法" scheme="https://lrtwjhs.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://lrtwjhs.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode-Easy" scheme="https://lrtwjhs.github.io/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 14. Longest Common Prefix</title>
    <link href="https://lrtwjhs.github.io/2020/12/24/2020-12-24-leetcode-14/"/>
    <id>https://lrtwjhs.github.io/2020/12/24/2020-12-24-leetcode-14/</id>
    <published>2020-12-23T16:00:00.000Z</published>
    <updated>2020-12-24T13:46:53.020Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接:</strong><br><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="external">https://leetcode.com/problems/longest-common-prefix/</a></p><p><strong>思路:</strong><br>将单词上下排好，则相当于一个各行长度有可能不相等的二维数组，遍历顺序和一般的横向逐行遍历不同，而是采用纵向逐列遍历，在遍历的过程中，如果某一行没有了，说明其为最短的单词，因为共同前缀的长度不能长于最短单词，所以此时返回已经找出的共同前缀。</p><p><strong>Solution:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String pre = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; strs.length)&#123;</span><br><span class="line">            <span class="keyword">while</span> (strs[i].indexOf(pre) != <span class="number">0</span>)</span><br><span class="line">                pre = pre.substring(<span class="number">0</span>, pre.length() - <span class="number">1</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目链接:&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-common-prefix/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://leetcode.
      
    
    </summary>
    
      <category term="算法" scheme="https://lrtwjhs.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://lrtwjhs.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode-Easy" scheme="https://lrtwjhs.github.io/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 9. Palindrome Number</title>
    <link href="https://lrtwjhs.github.io/2020/12/23/2020-12-23-leetcode-9/"/>
    <id>https://lrtwjhs.github.io/2020/12/23/2020-12-23-leetcode-9/</id>
    <published>2020-12-22T16:00:00.000Z</published>
    <updated>2020-12-23T15:12:53.889Z</updated>
    
    <content type="html"><![CDATA[<p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><p>Follow up: Could you solve it without converting the integer to a string?</p><a id="more"></a><p><strong>Example 1:</strong><br>Input: x = 121<br>Output: true</p><p><strong>Example 2:</strong><br>Input: x = -121<br>Output: false<br>Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</p><p><strong>Example 3:</strong><br>Input: x = 10<br>Output: false<br>Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</p><p><strong>Example 4:</strong><br>Input: x = -101<br>Output: false</p><p><strong>Constraints:</strong><br>-2^31 &lt;= x &lt;= 2^31 - 1</p><p><strong>思路:</strong><br>要验证回文数，那么就需要看前后半段是否对称，如果把后半段翻转一下，就看和前半段是否相等就行了，所以做法就是取出后半段数字，进行翻转。</p><p><strong>Solution:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> revertNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertNum) &#123;</span><br><span class="line">            revertNum = revertNum * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == revertNum || x == revertNum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.&lt;/p&gt;
&lt;p&gt;Follow up: Could you solve it without converting the integer to a string?&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://lrtwjhs.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://lrtwjhs.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode-Easy" scheme="https://lrtwjhs.github.io/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 13. Roman to Integer</title>
    <link href="https://lrtwjhs.github.io/2020/12/23/2020-12-23-leetcode-13/"/>
    <id>https://lrtwjhs.github.io/2020/12/23/2020-12-23-leetcode-13/</id>
    <published>2020-12-22T16:00:00.000Z</published>
    <updated>2020-12-23T15:15:50.782Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接:</strong><br><a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="external">https://leetcode.com/problems/roman-to-integer/</a></p><p><strong>思路:</strong><br>用HashMap类，用字符型作为key，其对应的数为value。当一个字符代表的数小于其后一个字符代表的数时，这个数等于后一个字符代表的数减去该字符代表的数，否则等于二者相加。用HashMap是因为不需要思考如何遍历，直接找到Key就行。</p><p><strong>Solution:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">         Map &lt; Character, Integer &gt; map = <span class="keyword">new</span> HashMap &lt; &gt; ();</span><br><span class="line">         map.put(<span class="string">'I'</span>, <span class="number">1</span>);</span><br><span class="line">         map.put(<span class="string">'V'</span>, <span class="number">5</span>);</span><br><span class="line">         map.put(<span class="string">'X'</span>, <span class="number">10</span>);</span><br><span class="line">         map.put(<span class="string">'L'</span>, <span class="number">50</span>);</span><br><span class="line">         map.put(<span class="string">'C'</span>, <span class="number">100</span>);</span><br><span class="line">         map.put(<span class="string">'D'</span>, <span class="number">500</span>);</span><br><span class="line">         map.put(<span class="string">'M'</span>, <span class="number">1000</span>);</span><br><span class="line">         <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(i &lt; s.length()) &#123;</span><br><span class="line">             <span class="keyword">if</span>((i + <span class="number">1</span> &lt; s.length()) &amp;&amp; map.get(s.charAt(i + <span class="number">1</span>)) &gt; map.get(s.charAt(i))) &#123;</span><br><span class="line">                 ans += map.get(s.charAt(i + <span class="number">1</span>)) - (<span class="keyword">int</span>) map.get(s.charAt(i));</span><br><span class="line">                 i += <span class="number">2</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 ans += map.get(s.charAt(i));</span><br><span class="line">                 i++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目链接:&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://leetcode.com/problems/roman-to-integer/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://leetcode.com/p
      
    
    </summary>
    
      <category term="算法" scheme="https://lrtwjhs.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://lrtwjhs.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode-Easy" scheme="https://lrtwjhs.github.io/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1. Two Sum</title>
    <link href="https://lrtwjhs.github.io/2020/11/10/2020-11-10-leetcode-1/"/>
    <id>https://lrtwjhs.github.io/2020/11/10/2020-11-10-leetcode-1/</id>
    <published>2020-11-09T16:00:00.000Z</published>
    <updated>2020-12-24T14:36:01.723Z</updated>
    
    <content type="html"><![CDATA[<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution.</p><a id="more"></a><p><strong>Example:</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure></p><p><strong>思路:</strong><br>假设每个输入都只有一个解决方案，先新建一个Map集合，先循环一遍nums数组，以target - nums[i]为key，以索引i为value，<br>放入Map中；然后再循环一遍nums数组，以nums[i]为key，取出v，如果v存在且不等与i，则代表找到了匹配值，返回唯一解int[]{i, v}。</p><p><strong>Solution:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            m.put(target - nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line"></span><br><span class="line">            Integer v = m.get(nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(v != <span class="keyword">null</span> &amp;&amp; v != i)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, v&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given an array of integers, return &lt;strong&gt;indices&lt;/strong&gt; of the two numbers such that they add up to a specific target.&lt;/p&gt;
&lt;p&gt;You may assume that each input would have &lt;strong&gt;exactly&lt;/strong&gt; one solution.&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://lrtwjhs.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://lrtwjhs.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode-Easy" scheme="https://lrtwjhs.github.io/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2. Add Two Numbers</title>
    <link href="https://lrtwjhs.github.io/2020/11/10/2020-11-10-leetcode-2/"/>
    <id>https://lrtwjhs.github.io/2020/11/10/2020-11-10-leetcode-2/</id>
    <published>2020-11-09T16:00:00.000Z</published>
    <updated>2020-12-24T14:36:31.315Z</updated>
    
    <content type="html"><![CDATA[<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><a id="more"></a><p><strong>Input:</strong> (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p><p><strong>Output:</strong> 7 -&gt; 0 -&gt; 8</p><p><strong>思路:</strong><br>将长度较短的链表在末尾补零使得两个连表长度相等，再一个一个元素对其相加（考虑进位）<br>1.获取两个链表所对应的长度<br>2.在较短的链表末尾补零<br>3.对齐相加考虑进位</p><p><strong>Solution:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode r = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode h = r;</span><br><span class="line">        ListNode beforeend = r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            r.val += l1.val + l2.val;</span><br><span class="line"></span><br><span class="line">            r.next = <span class="keyword">new</span> ListNode(r.val / <span class="number">10</span>);</span><br><span class="line">            r.val %= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            beforeend = r;</span><br><span class="line">            r = r.next;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode rest;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) rest = l2; <span class="keyword">else</span> rest =l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(rest != <span class="keyword">null</span>)&#123;</span><br><span class="line">            r.val += rest.val;</span><br><span class="line"></span><br><span class="line">            r.next = <span class="keyword">new</span> ListNode(r.val / <span class="number">10</span>);</span><br><span class="line">            r.val %= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            beforeend = r;</span><br><span class="line">            r = r.next;</span><br><span class="line">            rest = rest.nest;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(beforeend.next != <span class="keyword">null</span> &amp;&amp; beforeend.next.val == <span class="number">0</span>) beforeend.next=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;You are given two &lt;strong&gt;non-empty&lt;/strong&gt; linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.&lt;/p&gt;
&lt;p&gt;You may assume the two numbers do not contain any leading zero, except the number 0 itself.&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://lrtwjhs.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://lrtwjhs.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode-Medium" scheme="https://lrtwjhs.github.io/tags/LeetCode-Medium/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 7. Reverse Integer</title>
    <link href="https://lrtwjhs.github.io/2020/11/10/2020-11-10-leetcode-7/"/>
    <id>https://lrtwjhs.github.io/2020/11/10/2020-11-10-leetcode-7/</id>
    <published>2020-11-09T16:00:00.000Z</published>
    <updated>2020-12-23T15:12:55.783Z</updated>
    
    <content type="html"><![CDATA[<p>Given a 32-bit signed integer, reverse digits of an integer.</p><p><strong>Note:</strong><br>Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><a id="more"></a><p><strong>Example 1:</strong><br>Input: x = 123<br>Output: 321</p><p><strong>Example 2:</strong><br>Input: x = -123<br>Output: -321</p><p><strong>Example 3:</strong><br>Input: x = 120<br>Output: 21</p><p><strong>Example 4:</strong><br>Input: x = 0<br>Output: 0</p><p><strong>Constraints:</strong><br>-2^31 &lt;= x &lt;= 2^31 - 1</p><p><strong>思路:</strong><br>直接循环读出末尾数据，负数也可以同样处理，如果溢出32位的话就返回0。</p><p><strong>Solution:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            ret = ret * <span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ret &gt; Integer.MAX_VALUE || ret &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a 32-bit signed integer, reverse digits of an integer.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://lrtwjhs.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://lrtwjhs.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode-Easy" scheme="https://lrtwjhs.github.io/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="https://lrtwjhs.github.io/2018/09/05/2018-09-05-http-status-code/"/>
    <id>https://lrtwjhs.github.io/2018/09/05/2018-09-05-http-status-code/</id>
    <published>2018-09-04T16:00:00.000Z</published>
    <updated>2021-02-01T12:53:38.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p><p>HTTP状态码的英文为HTTP Status Code，是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。</p><p>HTTP状态码的官方注册表由互联网号码分配局（Internet Assigned Numbers Authority）维护。</p><p>微软互联网信息服务 （Microsoft Internet Information Services）有时会使用额外的十进制子代码来获取更多具体信息，但是这些子代码仅出现在响应有效内容和文档中，而不是代替实际的HTTP状态代码。</p><a id="more"></a><h2 id="HTTP状态码分类"><a href="#HTTP状态码分类" class="headerlink" title="HTTP状态码分类"></a>HTTP状态码分类</h2><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p><p>HTTP状态码分类:</p><table><thead><tr><th style="text-align:left">分类</th><th style="text-align:left">分类描述</th></tr></thead><tbody><tr><td style="text-align:left">1**</td><td style="text-align:left">消息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td style="text-align:left">2**</td><td style="text-align:left">成功，操作被成功接收并处理</td></tr><tr><td style="text-align:left">3**</td><td style="text-align:left">重定向，需要进一步的操作以完成请求</td></tr><tr><td style="text-align:left">4**</td><td style="text-align:left">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td style="text-align:left">5**</td><td style="text-align:left">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><h2 id="一、1xx消息"><a href="#一、1xx消息" class="headerlink" title="一、1xx消息"></a>一、1xx消息</h2><p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。</p><h3 id="100-Continue"><a href="#100-Continue" class="headerlink" title="100 Continue"></a>100 Continue</h3><font face="微软雅黑" size="2"><em>服务器已经接收到请求头，并且客户端应继续发送请求主体（在需要发送身体的请求的情况下：例如，POST请求），或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。要使服务器检查请求的头部，客户端必须在其初始请求中发送Expect: 100-continue作为头部，并在发送正文之前接收100 Continue状态代码。响应代码417期望失败表示请求不应继续。</em></font><h3 id="101-Switching-Protocols"><a href="#101-Switching-Protocols" class="headerlink" title="101 Switching Protocols"></a>101 Switching Protocols</h3><font face="微软雅黑" size="2"><em>服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。</em></font><font face="微软雅黑" size="2"><em>只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本（如HTTP/2）比旧版本更有优势，或者切换到一个实时且同步的协议（如WebSocket）以传送利用此类特性的资源。</em></font><h3 id="102-Processing（WebDAV；RFC-2518）"><a href="#102-Processing（WebDAV；RFC-2518）" class="headerlink" title="102 Processing（WebDAV；RFC 2518）"></a>102 Processing（WebDAV；RFC 2518）</h3><font face="微软雅黑" size="2"><em>WebDAV请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。该代码表示​​服务器已经收到并正在处理请求，但无响应可用。[6]这样可以防止客户端超时，并假设请求丢失。</em></font><h2 id="二、2xx成功"><a href="#二、2xx成功" class="headerlink" title="二、2xx成功"></a>二、2xx成功</h2><p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</p><h3 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h3><font face="微软雅黑" size="2"><em>请求已成功，请求所希望的响应头或数据体将随此响应返回。实际的响应将取决于所使用的请求方法。在GET请求中，响应将包含与请求的资源相对应的实体。在POST请求中，响应将包含描述或操作结果的实体。</em></font><h3 id="201-Created"><a href="#201-Created" class="headerlink" title="201 Created"></a>201 Created</h3><font face="微软雅黑" size="2"><em>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</em></font><h3 id="202-Accepted"><a href="#202-Accepted" class="headerlink" title="202 Accepted"></a>202 Accepted</h3><font face="微软雅黑" size="2"><em>服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理发生时被禁止。</em></font><h3 id="203-Non-Authoritative-Information（自HTTP-1-1起）"><a href="#203-Non-Authoritative-Information（自HTTP-1-1起）" class="headerlink" title="203 Non-Authoritative Information（自HTTP / 1.1起）"></a>203 Non-Authoritative Information（自HTTP / 1.1起）</h3><font face="微软雅黑" size="2"><em>服务器是一个转换代理服务器（transforming proxy，例如网络加速器），以200 OK状态码为起源，但回应了原始响应的修改版本。</em></font><h3 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h3><font face="微软雅黑" size="2"><em>服务器成功处理了请求，没有返回任何内容。</em></font><h3 id="205-Reset-Content"><a href="#205-Reset-Content" class="headerlink" title="205 Reset Content"></a>205 Reset Content</h3><font face="微软雅黑" size="2"><em>服务器成功处理了请求，但没有返回任何内容。与204响应不同，此响应要求请求者重置文档视图。</em></font><h3 id="206-Partial-Content（RFC-7233）"><a href="#206-Partial-Content（RFC-7233）" class="headerlink" title="206 Partial Content（RFC 7233）"></a>206 Partial Content（RFC 7233）</h3><font face="微软雅黑" size="2"><em>服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</em></font><h3 id="207-Multi-Status-WebDAV；RFC-4918）"><a href="#207-Multi-Status-WebDAV；RFC-4918）" class="headerlink" title="207 Multi-Status (WebDAV；RFC 4918）"></a>207 Multi-Status (WebDAV；RFC 4918）</h3><font face="微软雅黑" size="2"><em>代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</em></font><h3 id="208-Already-Reported-（WebDAV；RFC-5842）"><a href="#208-Already-Reported-（WebDAV；RFC-5842）" class="headerlink" title="208 Already Reported （WebDAV；RFC 5842）"></a>208 Already Reported （WebDAV；RFC 5842）</h3><font face="微软雅黑" size="2"><em>DAV绑定的成员已经在（多状态）响应之前的部分被列举，且未被再次包含。</em></font><h3 id="226-IM-Used-（RFC-3229）"><a href="#226-IM-Used-（RFC-3229）" class="headerlink" title="226 IM Used （RFC 3229）"></a>226 IM Used （RFC 3229）</h3><font face="微软雅黑" size="2"><em>服务器已经满足了对资源的请求，对实体请求的一个或多个实体操作的结果表示。</em></font><h2 id="三、3XX重定向"><a href="#三、3XX重定向" class="headerlink" title="三、3XX重定向"></a>三、3XX重定向</h2><p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。</p><p>当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。</p><h3 id="300-Multiple-Choices"><a href="#300-Multiple-Choices" class="headerlink" title="300 Multiple Choices"></a>300 Multiple Choices</h3><font face="微软雅黑" size="2"><em>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</em><br></font><font face="微软雅黑" size="2"><em>除非这是一个HEAD请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由Content-Type定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。</em><br></font><font face="微软雅黑" size="2"><em>如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的URI；浏览器可能会将这个Location值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</em></font><h3 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h3><font face="微软雅黑" size="2"><em>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修</em><br></font><font face="微软雅黑" size="2"><em>改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</em><br></font><font face="微软雅黑" size="2"><em>新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。</em><br></font><font face="微软雅黑" size="2"><em>如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</em><br></font><font face="微软雅黑" size="2"><em>注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。</em></font><h3 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h3><font face="微软雅黑" size="2"><em>要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</em><br></font><font face="微软雅黑" size="2"><em>新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。</em><br></font><font face="微软雅黑" size="2"><em>如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</em><br></font><font face="微软雅黑" size="2"><em>注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。因此状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</em></font><h3 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h3><font face="微软雅黑" size="2"><em>对应当前请求的响应可以在另一个URI上被找到，当响应于POST（或PUT / DELETE）接收到响应时，客户端应该假定服务器已经收到数据，并且应该使用单独的GET消息发出重定向。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。</em><br></font><font face="微软雅黑" size="2"><em>新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。</em><br></font><font face="微软雅黑" size="2"><em>注意：许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</em></font><h3 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h3><font face="微软雅黑" size="2"><em>表示资源未被修改，因为请求头指定的版本If-Modified-Since或If-None-Match。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。</em></font><h3 id="305-Use-Proxy"><a href="#305-Use-Proxy" class="headerlink" title="305 Use Proxy"></a>305 Use Proxy</h3><font face="微软雅黑" size="2"><em>被请求的资源必须通过指定的代理才能被访问。Location域中将给出指定的代理所在的URI信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能创建305响应。许多HTTP客户端（像是Mozilla和Internet Explorer）都没有正确处理这种状态代码的响应，主要是出于安全考虑。</em><br></font><font face="微软雅黑" size="2"><em>注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</em></font><h3 id="306-Switch-Proxy"><a href="#306-Switch-Proxy" class="headerlink" title="306 Switch Proxy"></a>306 Switch Proxy</h3><font face="微软雅黑" size="2"><em>在最新版的规范中，306状态码已经不再被使用。最初是指“后续请求应使用指定的代理”。</em></font><h3 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h3><font face="微软雅黑" size="2"><em>在这种情况下，请求应该与另一个URI重复，但后续的请求应仍使用原始的URI。 与302相反，当重新发出原始请求时，不允许更改请求方法。 例如，应该使用另一个POST请求来重复POST请求。</em></font><h2 id="四、4XX客户端错误"><a href="#四、4XX客户端错误" class="headerlink" title="四、4XX客户端错误"></a>四、4XX客户端错误</h2><p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。</p><p>如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后</p><h3 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h3><font face="微软雅黑" size="2"><em>由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。</em></font><h3 id="401-Unauthorized（RFC-7235）"><a href="#401-Unauthorized（RFC-7235）" class="headerlink" title="401 Unauthorized（RFC 7235）"></a>401 Unauthorized（RFC 7235）</h3><font face="微软雅黑" size="2"><em>类似于403 Forbidden，401语义即“未认证”，即用户没有必要的凭据。该状态码表示当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。</em><br></font><font face="微软雅黑" size="2"><em>注意：当网站（通常是网站域名）禁止IP地址时，有些网站状态码显示的401，表示该特定地址被拒绝访问网站。</em></font><h3 id="402-Payment-Required"><a href="#402-Payment-Required" class="headerlink" title="402 Payment Required"></a>402 Payment Required</h3><font face="微软雅黑" size="2"><em>该状态码是为了将来可能的需求而预留的。该状态码最初的意图可能被用作某种形式的数字现金或在线支付方案的一部分，但几乎没有哪家服务商使用，而且这个状态码通常不被使用。如果特定开发人员已超过请求的每日限制，Google Developers API会使用此状态码。</em></font><h3 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h3><font face="微软雅黑" size="2"><em>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</em></font><h3 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h3><font face="微软雅黑" size="2"><em>请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</em></font><h3 id="405-Method-Not-Allowed"><a href="#405-Method-Not-Allowed" class="headerlink" title="405 Method Not Allowed"></a>405 Method Not Allowed</h3><font face="微软雅黑" size="2"><em>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。例如，需要通过POST呈现数据的表单上的GET请求，或只读资源上的PUT请求。</em><br></font><font face="微软雅黑" size="2"><em>鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</em></font><h3 id="406-Not-Acceptable"><a href="#406-Not-Acceptable" class="headerlink" title="406 Not Acceptable"></a>406 Not Acceptable</h3><font face="微软雅黑" size="2"><em>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，该请求不可接受。</em><br></font><font face="微软雅黑" size="2"><em>除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</em></font><h3 id="407-Proxy-Authentication-Required（RFC-2617）"><a href="#407-Proxy-Authentication-Required（RFC-2617）" class="headerlink" title="407 Proxy Authentication Required（RFC 2617）"></a>407 Proxy Authentication Required（RFC 2617）</h3><font face="微软雅黑" size="2"><em>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个Proxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy-Authorization信息头用以验证。</em></font><h3 id="408-Request-Timeout"><a href="#408-Request-Timeout" class="headerlink" title="408 Request Timeout"></a>408 Request Timeout</h3><font face="微软雅黑" size="2"><em>请求超时。根据HTTP规范，客户端没有在服务器预备等待的时间内完成一个请求的发送，客户端可以随时再次提交这一请求而无需进行任何更改。</em></font><h3 id="409-Conflict"><a href="#409-Conflict" class="headerlink" title="409 Conflict"></a>409 Conflict</h3><font face="微软雅黑" size="2"><em>表示因为请求存在冲突无法处理该请求，例如多个同步更新之间的编辑冲突。</em></font><h3 id="410-Gone"><a href="#410-Gone" class="headerlink" title="410 Gone"></a>410 Gone</h3><font face="微软雅黑" size="2"><em>表示所请求的资源不再可用，将不再可用。当资源被有意地删除并且资源应被清除时，应该使用这个。在收到410状态码后，用户应停止再次请求资源。但大多数服务端不会使用此状态码，而是直接使用404状态码。</em></font><h3 id="411-Length-Required"><a href="#411-Length-Required" class="headerlink" title="411 Length Required"></a>411 Length Required</h3><font face="微软雅黑" size="2"><em>服务器拒绝在没有定义Content-Length头的情况下接受请求。在添加了表明请求消息体长度的有效Content-Length头之后，客户端可以再次提交该请求。</em></font><h3 id="412-Precondition-Failed（RFC-7232）"><a href="#412-Precondition-Failed（RFC-7232）" class="headerlink" title="412 Precondition Failed（RFC 7232）"></a>412 Precondition Failed（RFC 7232）</h3><font face="微软雅黑" size="2"><em>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。[41]这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</em></font><h3 id="413-Request-Entity-Too-Large（RFC-7231）"><a href="#413-Request-Entity-Too-Large（RFC-7231）" class="headerlink" title="413 Request Entity Too Large（RFC 7231）"></a>413 Request Entity Too Large（RFC 7231）</h3><font face="微软雅黑" size="2"><em>前称“Request Entity Too Large”，表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。</em></font><font face="微软雅黑" size="2"><em>如果这个状况是临时的，服务器应当返回一个Retry-After的响应头，以告知客户端可以在多少时间以后重新尝试。</em></font><h3 id="414-Request-URI-Too-Long（RFC-7231）"><a href="#414-Request-URI-Too-Long（RFC-7231）" class="headerlink" title="414 Request-URI Too Long（RFC 7231）"></a>414 Request-URI Too Long（RFC 7231）</h3><font face="微软雅黑" size="2"><em>前称“Request-URI Too Long”，[43]表示请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。通常将太多数据的结果编码为GET请求的查询字符串，在这种情况下，应将其转换为POST请求。这比较少见，通常的情况包括：</em></font><font face="微软雅黑" size="2"><br><em>- 本应使用POST方法的表单提交变成了GET方法，导致查询字符串过长。</em><br><em>- 重定向URI“黑洞”，例如每次重定向把旧的URI作为新的URI的一部分，导致在若干次重定向后URI超长。</em><br><em>- 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的URI，当GET后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[45]。没有此类漏洞的服务器，应当返回414状态码。</em><br></font><h3 id="415-Unsupported-Media-Type"><a href="#415-Unsupported-Media-Type" class="headerlink" title="415 Unsupported Media Type"></a>415 Unsupported Media Type</h3><font face="微软雅黑" size="2"><em>对于当前请求的方法和所请求的资源，请求中提交的互联网媒体类型并不是服务器中所支持的格式，因此请求被拒绝。例如，客户端将图像上传格式为svg，但服务器要求图像使用上传格式为jpg。</em></font><h3 id="416-Requested-Range-Not-Satisfiable（RFC-7233）"><a href="#416-Requested-Range-Not-Satisfiable（RFC-7233）" class="headerlink" title="416 Requested Range Not Satisfiable（RFC 7233）"></a>416 Requested Range Not Satisfiable（RFC 7233）</h3><font face="微软雅黑" size="2"><em>前称“Requested Range Not Satisfiable”。[46]客户端已经要求文件的一部分（Byte serving），但服务器不能提供该部分。例如，如果客户端要求文件的一部分超出文件尾端。</em></font><h3 id="417-Expectation-Failed"><a href="#417-Expectation-Failed" class="headerlink" title="417 Expectation Failed"></a>417 Expectation Failed</h3><font face="微软雅黑" size="2"><em>在请求头Expect中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服显的证据证明在当前路由的下一个节点上，Expect的内容无法被满足。</em></font><h3 id="418-I’m-a-teapot（RFC-2324）"><a href="#418-I’m-a-teapot（RFC-2324）" class="headerlink" title="418 I’m a teapot（RFC 2324）"></a>418 I’m a teapot（RFC 2324）</h3><font face="微软雅黑" size="2"><em>本操作码是在1998年作为IETF的传统愚人节笑话, 在RFC 2324超文本咖啡壶控制协议’中定义的，并不需要在真实的HTTP服务器中定义。当一个控制茶壶的HTCPCP收到BREW或POST指令要求其煮咖啡时应当回传此错误。[49]这个HTTP状态码在某些网站（包括Google.com）与项目（如Node.js、ASP.NET和Go语言）中用作彩蛋。</em></font><h3 id="420-Enhance-Your-Caim"><a href="#420-Enhance-Your-Caim" class="headerlink" title="420 Enhance Your Caim"></a>420 Enhance Your Caim</h3><font face="微软雅黑" size="2"><em>Twitter Search与Trends API在客户端被限速的情况下返回。</em></font><h3 id="421-Misdirected-Request-（RFC-7540）"><a href="#421-Misdirected-Request-（RFC-7540）" class="headerlink" title="421 Misdirected Request （RFC 7540）"></a>421 Misdirected Request （RFC 7540）</h3><font face="微软雅黑" size="2"><em>该请求针对的是无法产生响应的服务器（例如因为连接重用）。</em></font><h3 id="422-Unprocessable-Entity（WebDAV；RFC-4918-）"><a href="#422-Unprocessable-Entity（WebDAV；RFC-4918-）" class="headerlink" title="422 Unprocessable Entity（WebDAV；RFC 4918 ）"></a>422 Unprocessable Entity（WebDAV；RFC 4918 ）</h3><font face="微软雅黑" size="2"><em>请求格式正确，但是由于含有语义错误，无法响应。</em></font><h3 id="423-Locked（WebDAV；RFC-4918）"><a href="#423-Locked（WebDAV；RFC-4918）" class="headerlink" title="423 Locked（WebDAV；RFC 4918）"></a>423 Locked（WebDAV；RFC 4918）</h3><font face="微软雅黑" size="2"><em>当前资源被锁定。</em></font><h3 id="424-Failed-Dependency（WebDAV；RFC-4918）"><a href="#424-Failed-Dependency（WebDAV；RFC-4918）" class="headerlink" title="424 Failed Dependency（WebDAV；RFC 4918）"></a>424 Failed Dependency（WebDAV；RFC 4918）</h3><font face="微软雅黑" size="2"><em>由于之前的某个请求发生的错误，导致当前请求失败，例如PROPPATCH。</em></font><h3 id="425-Unodered-Cellection"><a href="#425-Unodered-Cellection" class="headerlink" title="425 Unodered Cellection"></a>425 Unodered Cellection</h3><font face="微软雅黑" size="2"><em>在WebDAV Advanced Collections Protocol中定义，但Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol中并不存在。</em></font><h3 id="426-Upgrade-Required（RFC-2817）"><a href="#426-Upgrade-Required（RFC-2817）" class="headerlink" title="426 Upgrade Required（RFC 2817）"></a>426 Upgrade Required（RFC 2817）</h3><font face="微软雅黑" size="2"><em>客户端应当切换到TLS/1.0，并在HTTP/1.1 Upgrade header中给出。</em></font><h3 id="428-Precondition-Required-RFC-6585"><a href="#428-Precondition-Required-RFC-6585" class="headerlink" title="428 Precondition Required (RFC 6585)"></a>428 Precondition Required (RFC 6585)</h3><font face="微软雅黑" size="2"><em>原服务器要求该请求满足一定条件。这是为了防止“‘未更新’问题，即客户端读取（GET）一个资源的状态，更改它，并将它写（PUT）回服务器，但这期间第三方已经在服务器上更改了该资源的状态，因此导致了冲突。”</em></font><h3 id="429-Too-Many-Requests-（RFC-6585）"><a href="#429-Too-Many-Requests-（RFC-6585）" class="headerlink" title="429 Too Many Requests （RFC 6585）"></a>429 Too Many Requests （RFC 6585）</h3><font face="微软雅黑" size="2"><em>用户在给定的时间内发送了太多的请求。旨在用于网络限速。</em></font><h3 id="431-Request-Header-Fields-Too-Large-（RFC-6585）"><a href="#431-Request-Header-Fields-Too-Large-（RFC-6585）" class="headerlink" title="431 Request Header Fields Too Large （RFC 6585）"></a>431 Request Header Fields Too Large （RFC 6585）</h3><font face="微软雅黑" size="2"><em>服务器不愿处理请求，因为一个或多个头字段过大。</em></font><h3 id="444-No-Response"><a href="#444-No-Response" class="headerlink" title="444 No Response"></a>444 No Response</h3><font face="微软雅黑" size="2"><em>Nginx上HTTP服务器扩展。服务器不向客户端返回任何信息，并关闭连接（有助于阻止恶意软件）。</em></font><h3 id="450-Blocked-by-Windows-Parental-Controls"><a href="#450-Blocked-by-Windows-Parental-Controls" class="headerlink" title="450 Blocked by Windows Parental Controls"></a>450 Blocked by Windows Parental Controls</h3><font face="微软雅黑" size="2"><em>这是一个由Windows家庭控制（Microsoft）HTTP阻止的450状态代码的示例，用于信息和测试。</em></font><h3 id="451-Unavailable-For-Legal-Reasons"><a href="#451-Unavailable-For-Legal-Reasons" class="headerlink" title="451 Unavailable For Legal Reasons"></a>451 Unavailable For Legal Reasons</h3><font face="微软雅黑" size="2"><em>该访问因法律的要求而被拒绝，由IETF在2015核准后新增加。</em></font><h3 id="494-Request-Header-Too-Large"><a href="#494-Request-Header-Too-Large" class="headerlink" title="494 Request Header Too Large"></a>494 Request Header Too Large</h3><font face="微软雅黑" size="2"><em>在错误代码431提出之前Nginx上使用的扩展HTTP代码。</em></font><h2 id="五、5XX服务器错误"><a href="#五、5XX服务器错误" class="headerlink" title="五、5XX服务器错误"></a>五、5XX服务器错误</h2><p>表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。</p><h3 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h3><font face="微软雅黑" size="2"><em>通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息。</em></font><h3 id="501-Not-Implemented"><a href="#501-Not-Implemented" class="headerlink" title="501 Not Implemented"></a>501 Not Implemented</h3><font face="微软雅黑" size="2"><em>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。（例如，网络服务API的新功能）</em></font><h3 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h3><font face="微软雅黑" size="2"><em>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</em></font><h3 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h3><font face="微软雅黑" size="2"><em>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是暂时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。</em></font><h3 id="504-Gateway-Timeout"><a href="#504-Gateway-Timeout" class="headerlink" title="504 Gateway Timeout"></a>504 Gateway Timeout</h3><font face="微软雅黑" size="2"><em>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。</em><br></font><font face="微软雅黑" size="2"><em>注意：某些代理服务器在DNS查询超时时会返回400或者500错误。</em></font><h3 id="505-HTTP-Version-Not-Supported"><a href="#505-HTTP-Version-Not-Supported" class="headerlink" title="505 HTTP Version Not Supported"></a>505 HTTP Version Not Supported</h3><font face="微软雅黑" size="2"><em>服务器不支持，或者拒绝支持在请求中使用的HTTP版本。[63]这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</em></font><h3 id="506-Variant-Also-Negotiates（RFC-2295）"><a href="#506-Variant-Also-Negotiates（RFC-2295）" class="headerlink" title="506 Variant Also Negotiates（RFC 2295）"></a>506 Variant Also Negotiates（RFC 2295）</h3><font face="微软雅黑" size="2"><em>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误，[64]被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</em></font><h3 id="507-Insufficient-Storage（WebDAV；RFC-4918）"><a href="#507-Insufficient-Storage（WebDAV；RFC-4918）" class="headerlink" title="507 Insufficient Storage（WebDAV；RFC 4918）"></a>507 Insufficient Storage（WebDAV；RFC 4918）</h3><font face="微软雅黑" size="2"><em>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。</em></font><h3 id="508-Loop-Detected-（WebDAV；RFC-5842）"><a href="#508-Loop-Detected-（WebDAV；RFC-5842）" class="headerlink" title="508 Loop Detected （WebDAV；RFC 5842）"></a>508 Loop Detected （WebDAV；RFC 5842）</h3><font face="微软雅黑" size="2"><em>服务器在处理请求时陷入死循环.（可代替 208状态码）</em></font><h3 id="510-Not-Extended（RFC-2774）"><a href="#510-Not-Extended（RFC-2774）" class="headerlink" title="510 Not Extended（RFC 2774）"></a>510 Not Extended（RFC 2774）</h3><font face="微软雅黑" size="2"><em>获取资源所需要的策略并没有被满足。</em></font><h3 id="511-Network-Authentication-Required-（RFC-6585）"><a href="#511-Network-Authentication-Required-（RFC-6585）" class="headerlink" title="511 Network Authentication Required （RFC 6585）"></a>511 Network Authentication Required （RFC 6585）</h3><font face="微软雅黑" size="2"><em>客户端需要进行身份验证才能获得网络访问权限，旨在限制用户群访问特定网络。（例如连接WiFi热点时的强制网络门户）</em></font>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP状态码&quot;&gt;&lt;a href=&quot;#HTTP状态码&quot; class=&quot;headerlink&quot; title=&quot;HTTP状态码&quot;&gt;&lt;/a&gt;HTTP状态码&lt;/h2&gt;&lt;p&gt;当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。&lt;/p&gt;
&lt;p&gt;HTTP状态码的英文为HTTP Status Code，是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。&lt;/p&gt;
&lt;p&gt;HTTP状态码的官方注册表由互联网号码分配局（Internet Assigned Numbers Authority）维护。&lt;/p&gt;
&lt;p&gt;微软互联网信息服务 （Microsoft Internet Information Services）有时会使用额外的十进制子代码来获取更多具体信息，但是这些子代码仅出现在响应有效内容和文档中，而不是代替实际的HTTP状态代码。&lt;/p&gt;
    
    </summary>
    
      <category term="协议" scheme="https://lrtwjhs.github.io/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="HTTP" scheme="https://lrtwjhs.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>开源许可协议GPL、BSD、MIT、Mozilla、Apache和LGPL的区别</title>
    <link href="https://lrtwjhs.github.io/2018/09/04/2018-09-04-open-source-license/"/>
    <id>https://lrtwjhs.github.io/2018/09/04/2018-09-04-open-source-license/</id>
    <published>2018-09-03T16:00:00.000Z</published>
    <updated>2021-02-01T12:53:15.075Z</updated>
    
    <content type="html"><![CDATA[<p>首先借用一张相当直观清晰的图来划分各种协议：开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别</p><a id="more"></a><p><img src="https://lrtwjhs.github.io/img/blog_post_20161209_01.jpg" alt="license\_img"></p><p>以下是上述协议的简单介绍：</p><h3 id="1-BSD开源协议"><a href="#1-BSD开源协议" class="headerlink" title="1. BSD开源协议"></a>1. BSD开源协议</h3><p>BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。</p><p>但”为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p><ul><li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议.</li><li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议.</li><li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广.</li></ul><p>BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p><h3 id="2-Apache-Licence-2-0"><a href="#2-Apache-Licence-2-0" class="headerlink" title="2. Apache Licence 2.0"></a>2. Apache Licence 2.0</h3><p>Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和BSD类似：</p><ul><li>需要给代码的用户一份Apache Licence.</li><li>如果你修改了代码，需要再被修改的文件中说明.</li><li>在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明.</li><li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改.</li></ul><p>Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。</p><h3 id="3-GPL"><a href="#3-GPL" class="headerlink" title="3. GPL"></a>3. GPL</h3><p>我们很熟悉的Linux就是采用了GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。</p><p>GPL协议的主要内容是只要在一个软件中使用(”使用”指类库引用，修改后的代码或者衍生代码)GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题，还可以享受免费的优势。</p><p>由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。</p><p>其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。</p><h3 id="4-LGPL"><a href="#4-LGPL" class="headerlink" title="4. LGPL"></a>4. LGPL</h3><p>LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL 允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p><p>但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p><p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。</p><h3 id="5-MIT"><a href="#5-MIT" class="headerlink" title="5. MIT"></a>5. MIT</h3><p>MPL是The Mozilla Public License的简写，是1998年初Netscape的 Mozilla小组为其开源软件项目设计的软件许可证。MPL许可证出现的最重要原因就是，Netscape公司认为GPL许可证没有很好地平衡开发者对源代码的需求和他们利用源代码获得的利益。同著名的GPL许可证和BSD许可证相比，MPL在许多权利与义务的约定方面与它们相同（因为都是符合OSIA 认定的开源软件许可证）。但是，相比而言MPL还有以下几个显著的不同之处:</p><ul><li>MPL虽然要求对于经MPL许可证发布的源代码的修改也要以MPL许可证的方式再许可出来，以保证其他人可以在MPL的条款下共享源代码。但是，在MPL 许可证中对“发布”的定义是“以源代码方式发布的文件”，这就意味着MPL允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以MPL 许可证的形式对外许可外，源代码库中的源代码就可以不用MPL许可证的方式强制对外许可。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个豁口.</li><li>MPL许可证第三条第7款中允许被许可人将经过MPL许可证获得的源代码同自己其他类型的代码混合得到自己的软件程序.</li><li>对软件专利的态度，MPL许可证不像GPL许可证那样明确表示反对软件专利，但是却明确要求源代码的提供者不能提供已经受专利保护的源代码（除非他本人是专利权人，并书面向公众免费许可这些源代码），也不能在将这些源代码以开放源代码许可证形式许可后再去申请与这些源代码有关的专利.</li><li>对源代码的定义，而在MPL（1.1版本）许可证中，对源代码的定义是:“源代码指的是对作品进行修改最优先择取的形式，它包括:所有模块的所有源程序，加上有关的接口的定义，加上控制可执行作品的安装和编译的‘原本’（原文为‘Script’），或者不是与初始源代码显著不同的源代码就是被源代码贡献者选择的从公共领域可以得到的程序代码.</li><li>MPL许可证第3条有专门的一款是关于对源代码修改进行描述的规定，就是要求所有再发布者都得有一个专门的文件就对源代码程序修改的时间和修改的方式有描述.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先借用一张相当直观清晰的图来划分各种协议：开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别&lt;/p&gt;
    
    </summary>
    
      <category term="协议" scheme="https://lrtwjhs.github.io/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="科普知识" scheme="https://lrtwjhs.github.io/tags/%E7%A7%91%E6%99%AE%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>推荐两款很安逸的离线API文档查询工具Dash和Zeal</title>
    <link href="https://lrtwjhs.github.io/2018/09/03/2018-09-03-offline-api-document/"/>
    <id>https://lrtwjhs.github.io/2018/09/03/2018-09-03-offline-api-document/</id>
    <published>2018-09-02T16:00:00.000Z</published>
    <updated>2021-02-01T12:52:36.485Z</updated>
    
    <content type="html"><![CDATA[<p>大家开发的时候难免会查询一些文档，看一下API的调用方法等，所以会不同的语言去某一个地方去找，确实很麻烦，今天给大家安逸两款软件，肯定会让你爱不释手！</p><a id="more"></a><h2 id="Dash-for-macOS"><a href="#Dash-for-macOS" class="headerlink" title="Dash for macOS"></a>Dash for macOS</h2><p>官方地址：<a href="https://kapeli.com/dash" target="_blank" rel="external">https://kapeli.com/dash</a></p><h3 id="1-官方简介"><a href="#1-官方简介" class="headerlink" title="1. 官方简介"></a>1. 官方简介</h3><p>Dash is an API Documentation Browser and Code Snippet Manager. Dash stores snippets of code and instantly searches offline documentation sets for 150+ APIs (for a full list, see below). You can even generate your own docsets or request docsets to be included.</p><h3 id="2-截图欣赏"><a href="#2-截图欣赏" class="headerlink" title="2. 截图欣赏"></a>2. 截图欣赏</h3><p><img src="https://lrtwjhs.github.io/img/blog_post_20121229_01.jpg" alt="Dash img 1"></p><p><img src="https://lrtwjhs.github.io/img/blog_post_20121229_02.jpg" alt="Dash img 2"></p><p><img src="https://lrtwjhs.github.io/img/blog_post_20121229_03.jpg" alt="Dash img 3"></p><h3 id="3-支持的语言"><a href="#3-支持的语言" class="headerlink" title="3. 支持的语言"></a>3. 支持的语言</h3><p>Dash comes with 150+ offline documentation sets. You can choose which documentation sets to download and Dash will take care of the rest, making sure they are kept up to date. You can also generate your own docsets, request docsets or download docsets from third-party sources.</p><p>Listed below are all the various documentation sets Dash comes with. The most popular ones are highlighted. All documentation sets have been generated and are maintained with the utmost care.</p><p><img src="https://lrtwjhs.github.io/img/blog_post_20121229_04.jpg" alt="Dash img 4"></p><p>并且还支持第三方平台提供的Documentation资源。</p><h3 id="4-价格"><a href="#4-价格" class="headerlink" title="4. 价格"></a>4. 价格</h3><p>目前的收费是24.9$ ,即使不购买也完全不影响正常的使用，只是在每一次打开的时候，第一次搜索需要等待10s时间，打开之后其他搜索就不需要在等待了！还是可以接受的！当然，也可以购买正版的软件。</p><h2 id="Zeal-for-Windows"><a href="#Zeal-for-Windows" class="headerlink" title="Zeal for Windows"></a>Zeal for Windows</h2><p>Dash方便的使用体验没有移植到Windows上，但是在Windows上也有相应的替代产品–Zeal，官网地址：<a href="https://zealdocs.org/" target="_blank" rel="external">https://zealdocs.org/</a></p><p><img src="https://lrtwjhs.github.io/img/blog_post_20121229_05.jpg" alt="Zeal img 1"></p><p>Zeal提供了和Dash一样的docsets文档，Dash有的API文档，这里也有</p><p><img src="https://lrtwjhs.github.io/img/blog_post_20121229_06.jpg" alt="Zeal img 2"></p><p>最重要的是Zeal是开源免费的！</p><h2 id="Dash和Zeal的简单对比"><a href="#Dash和Zeal的简单对比" class="headerlink" title="Dash和Zeal的简单对比"></a>Dash和Zeal的简单对比</h2><p>Dash和Zeal都提供了相应丰富的API文档，在资源的类别上不差上下，前着收费后者免费，但是在实际的体验中确实有一点差别：</p><p><strong><em>Dash：</em></strong></p><p><img src="https://lrtwjhs.github.io/img/blog_post_20121229_07.jpg" alt="comparison img 1"></p><p><strong><em>Zeal:</em></strong></p><p><img src="https://lrtwjhs.github.io/img/blog_post_20121229_08.jpg" alt="comparison img 2"></p><p>可以看出，如果作为Java开发者，我很要的是Dash所提供的给我的东西，而Zeal提供给我的确实上边的内容，但是直接搜索方法的话，效果还是很好的：</p><p><img src="https://lrtwjhs.github.io/img/blog_post_20121229_09.jpg" alt="comparison img 3"></p><p>其他的就不做多的对比了，根据喜好和设备进行选取吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家开发的时候难免会查询一些文档，看一下API的调用方法等，所以会不同的语言去某一个地方去找，确实很麻烦，今天给大家安逸两款软件，肯定会让你爱不释手！&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://lrtwjhs.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="科普知识" scheme="https://lrtwjhs.github.io/tags/%E7%A7%91%E6%99%AE%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Mac 终端里神秘的 bogon 及解决方法</title>
    <link href="https://lrtwjhs.github.io/2018/09/02/2018-09-02-mac-bogon-solution/"/>
    <id>https://lrtwjhs.github.io/2018/09/02/2018-09-02-mac-bogon-solution/</id>
    <published>2018-09-01T16:00:00.000Z</published>
    <updated>2021-02-01T12:51:26.400Z</updated>
    
    <content type="html"><![CDATA[<p>Mac 下的终端经常有时候前面的计算机名会错误的显示成 bogon,这个单词是虚拟、虚伪的意思。这是因为终端会先向 DNS服务器 请求查询当前 IP 的反向域名解析的结果，如果查询不到再显示我们设置的计算机名。</p><p>而由于我们的 DNS服务器 错误地将保留地址反向的 NS 查询结果返回了 bogon。其中 bogon 本应该用来指虚假的 IP 地址，而非保留 IP 地址。因此就出现了会时不时地打印 bogon 这种奇怪名字作为计算机名的现象了。那么如何让终端只显示我们想要的计算机名而不总是从 DNS 返回结果呢？</p><a id="more"></a><p>方法有二：</p><p>一. 将DNS设置为其他的DNS服务器，如Google的DNS服务器地址  8.8.8.8</p><p>二. 在终端中执行以下命令即可（需要输入一次管理员密码)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo hostname your-desired-host-name</span><br><span class="line">sudo scutil --set LocalHostName $(hostname)</span><br><span class="line">sudo scutil --set HostName $(hostname)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mac 下的终端经常有时候前面的计算机名会错误的显示成 bogon,这个单词是虚拟、虚伪的意思。这是因为终端会先向 DNS服务器 请求查询当前 IP 的反向域名解析的结果，如果查询不到再显示我们设置的计算机名。&lt;/p&gt;
&lt;p&gt;而由于我们的 DNS服务器 错误地将保留地址反向的 NS 查询结果返回了 bogon。其中 bogon 本应该用来指虚假的 IP 地址，而非保留 IP 地址。因此就出现了会时不时地打印 bogon 这种奇怪名字作为计算机名的现象了。那么如何让终端只显示我们想要的计算机名而不总是从 DNS 返回结果呢？&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://lrtwjhs.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Mac" scheme="https://lrtwjhs.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（三）之 Srting操作方法</title>
    <link href="https://lrtwjhs.github.io/2017/08/19/2017-08-19-javascript-string/"/>
    <id>https://lrtwjhs.github.io/2017/08/19/2017-08-19-javascript-string/</id>
    <published>2017-08-18T16:00:00.000Z</published>
    <updated>2021-02-01T12:48:20.583Z</updated>
    
    <content type="html"><![CDATA[<p>String 类型用于表示由零或多个 16 位 Unicode 字符组成的字符序列，即字符串 。</p><h3 id="1-关于-Unicode"><a href="#1-关于-Unicode" class="headerlink" title="1. 关于 Unicode"></a>1. 关于 Unicode</h3><p>由于计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。在计算机中，1个字节（byte）由 8个比特（bit）组成，所以 1 个字节能表示的最大整数就是 255（28 个），如果想表示更大整数，就必须用更多的字节，比如 2 个字节可以表示的最大整数为 65535 ，即 216  个。</p><a id="more"></a><p>最早只有 127 个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为 ASCII 编码，比如大写字母 A 的编码是 65，小写字母 z 的编码是122。但如果要处理中文字符，显然一个字节是不够的，至少需要两个字节，所以，中国制定了GB2312 编码，用来把中文编进去。同样，其他国家的语言也会存在这个问题，因此，各国都制定了自己特有的编码规范。这样存在的问题是，在多语言混合的文本中，不同的编码会出现冲突，导致乱码出现。</p><p>如果想要解决这个问题，就需要制定一种通用的编码，能把所有语言都统一到一套编码里，统一进行管理，这种编码就是 Unicode 编码 。Unicode 通常用 2 个字节来表示独一无二的字符， 如果要用到非常偏僻的字符，就需要 4 个字节 。</p><p>因此，JavaScript 中的字符采用 16 位的 Unicode 编码来表示，也就是说，英文字符和中文字符都会占 2 个字节的空间大小。</p><h3 id="2-常用操作方法"><a href="#2-常用操作方法" class="headerlink" title="2. 常用操作方法"></a>2. 常用操作方法</h3><p>作为字符串的基本包装对象，String 提供了以下几类方法来操作字符串：</p><p><strong><em>[1] 字符操作：charAt 、charCodeAt、fromCharCode</em></strong></p><p>charAt 用于获取指定位置上的字符，chatCodeAt 则是获取指定位置字符的 Unicode 编码（10进制表示），fromCharCode 是 String 上的一个静态方法，通过Unicode 获取对应的字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'abc'</span>;</span><br><span class="line">str.charAt(<span class="number">1</span>); <span class="comment">// b</span></span><br><span class="line">str.charCodeAt(<span class="number">1</span>); <span class="comment">// 98</span></span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">98</span>); <span class="comment">// a</span></span><br></pre></td></tr></table></figure><p><strong><em>[2] 字符串提取：substr、substring 、slice</em></strong></p><p>这三个方法都可以对原字符串按位置进行提取，并返回一个新的字符串 。 其用法如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">stringValue.slice(<span class="number">3</span>); <span class="comment">//"lo world"</span></span><br><span class="line">stringValue.substring(<span class="number">3</span>); <span class="comment">//"lo world"</span></span><br><span class="line">stringValue.substr(<span class="number">3</span>); <span class="comment">//"lo world"</span></span><br><span class="line">stringValue.slice(<span class="number">3</span>, <span class="number">7</span>); <span class="comment">//"lo w"</span></span><br><span class="line">stringValue.substring(<span class="number">3</span>,<span class="number">7</span>); <span class="comment">//"lo w"</span></span><br><span class="line">stringValue.substr(<span class="number">3</span>, <span class="number">7</span>); <span class="comment">//"lo worl"</span></span><br></pre></td></tr></table></figure><p>如果传递的参数为负值，它们的表现会不尽相同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">stringValue.slice(<span class="number">-3</span>); <span class="comment">//"rld"</span></span><br><span class="line">stringValue.substring(<span class="number">-3</span>); <span class="comment">//"hello world"</span></span><br><span class="line">stringValue.substr(<span class="number">-3</span>); <span class="comment">//"rld"</span></span><br><span class="line">stringValue.slice(<span class="number">3</span>, <span class="number">-4</span>); <span class="comment">//"lo w"</span></span><br><span class="line">stringValue.substring(<span class="number">3</span>, <span class="number">-4</span>); <span class="comment">//"hel"</span></span><br><span class="line">stringValue.substr(<span class="number">3</span>, <span class="number">-4</span>); <span class="comment">//""（空字符串）</span></span><br></pre></td></tr></table></figure><p><strong><em>[3] 位置索引：indexOf 、lastIndexOf</em></strong></p><p>indexOf() 方法从字符串的开头向后搜索子字符串，而 lastIndexOf() 方法是从字符串的末尾向前搜索子字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">stringValue.indexOf(<span class="string">"o"</span>); <span class="comment">//4</span></span><br><span class="line">stringValue.lastIndexOf(<span class="string">"o"</span>); <span class="comment">//7</span></span><br></pre></td></tr></table></figure><p>这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">stringValue.indexOf(<span class="string">"o"</span>, <span class="number">6</span>); <span class="comment">//7</span></span><br><span class="line">stringValue.lastIndexOf(<span class="string">"o"</span>, <span class="number">6</span>); <span class="comment">//4</span></span><br></pre></td></tr></table></figure><p><strong><em>[4] 大小写转换：toLowerCase、toUpperCase</em></strong></p><p>ECMAScript 中涉及字符串大小写转换的方法有4 个：toLowerCase()、toLocaleLowerCase()、toUpperCase() 和 toLocaleUpperCase()。其中，toLowerCase() 和 toUpperCase() 是两个经典的方法，借鉴自java.lang.String 中的同名方法。而 toLocaleLowerCase() 和toLocaleUpperCase() 方法则是针对特定地区的实现。对有些地区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言（如土耳其语）会为 Unicode 大小写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">stringValue.toLocaleUpperCase(); <span class="comment">//"HELLO WORLD"</span></span><br><span class="line">stringValue.toUpperCase(); <span class="comment">//"HELLO WORLD"</span></span><br><span class="line">stringValue.toLocaleLowerCase(); <span class="comment">//"hello world"</span></span><br><span class="line">stringValue.toLowerCase(); <span class="comment">//"hello world"</span></span><br></pre></td></tr></table></figure><p>一般来说，在不知道自己的代码将在哪种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。</p><p><strong><em>[5] 模拟匹配：match、search、replace、split</em></strong></p><p>match() 本质上与调用 RegExp 的 exec()方法相同。match() 方法只接受一个参数，要么是一个正则表达式，要么是一个 RegExp 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="comment">//与pattern.exec(text)相同</span></span><br><span class="line"><span class="keyword">var</span> matches = text.match(pattern);</span><br><span class="line">alert(matches.index); <span class="comment">//0</span></span><br><span class="line">alert(matches[<span class="number">0</span>]); <span class="comment">//"cat"</span></span><br><span class="line">alert(pattern.lastIndex); <span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>本例中的 match() 方法返回了一个数组；如果是调用RegExp 对象的 exec()方法并传递本例中的字符串作为参数，那么也会得到与此相同的数组：数组的第一项是与整个模式匹配的字符串，之后的每一项（如果有）保存着与正则表达式中的捕获组匹配的字符串。</p><p>search() 的唯一参数与 match() 方法的参数相同：由字符串或 RegExp 对象指定的一个正则表达式。search() 方法返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1。而且，search() 方法始终是从字符串开头向后查找模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">var</span> pos = text.search(<span class="regexp">/at/</span>);</span><br><span class="line">aler t(pos); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>replace() 接受两个参数：第一个参数可以是一个RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(<span class="string">"at"</span>, <span class="string">"ond"</span>);</span><br><span class="line">alert(result); <span class="comment">//"cond, bat, sat, fat"</span></span><br><span class="line">result = text.replace(<span class="regexp">/at/g</span>, <span class="string">"ond"</span>);</span><br><span class="line">aler t(result); <span class="comment">//"cond, bond, sond, fond"</span></span><br></pre></td></tr></table></figure><p>replace() 方法的第二个参数也可以是一个函数。在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递3 个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为replace()方法的第二个参数可以实现更加精细的替换操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> text.replace(<span class="regexp">/[&lt;&gt;"&amp;]/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, pos, originalText</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (match) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"&lt;"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;"</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"&gt;"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&gt;"</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"&amp;"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&amp;"</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"\""</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span><span class="string">";</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>split() 可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp 对象（这个方法不会将字符串看成正则表达式）。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colorText = <span class="string">"red,blue,green,yellow"</span>;</span><br><span class="line"><span class="keyword">var</span> colors1 = colorText.split(<span class="string">","</span>); <span class="comment">//["red", "blue", "green", "yellow"]</span></span><br><span class="line"><span class="keyword">var</span> colors2 = colorText.split(<span class="string">","</span>, <span class="number">2</span>); <span class="comment">//["red", "blue"]</span></span><br><span class="line"><span class="keyword">var</span> colors3 = colorText.split(<span class="regexp">/[^\,]+/</span>); <span class="comment">//["", ",", ",", ",", ""]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;String 类型用于表示由零或多个 16 位 Unicode 字符组成的字符序列，即字符串 。&lt;/p&gt;
&lt;h3 id=&quot;1-关于-Unicode&quot;&gt;&lt;a href=&quot;#1-关于-Unicode&quot; class=&quot;headerlink&quot; title=&quot;1. 关于 Unicode&quot;&gt;&lt;/a&gt;1. 关于 Unicode&lt;/h3&gt;&lt;p&gt;由于计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。在计算机中，1个字节（byte）由 8个比特（bit）组成，所以 1 个字节能表示的最大整数就是 255（28 个），如果想表示更大整数，就必须用更多的字节，比如 2 个字节可以表示的最大整数为 65535 ，即 216  个。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript学习笔记" scheme="https://lrtwjhs.github.io/categories/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端开发" scheme="https://lrtwjhs.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（二）之 判断数据类型的四种方法</title>
    <link href="https://lrtwjhs.github.io/2017/08/18/2017-08-18-javascript-determine-datatype/"/>
    <id>https://lrtwjhs.github.io/2017/08/18/2017-08-18-javascript-determine-datatype/</id>
    <published>2017-08-17T16:00:00.000Z</published>
    <updated>2021-02-01T12:42:16.287Z</updated>
    
    <content type="html"><![CDATA[<p>在 ECMAScript 规范中，共定义了 7 种数据类型，分为 基本类型 和 引用类型 两大类，如下所示：</p><p>基本类型：Null,Undefined,String,Number,Boolean,Symbol(ES6)</p><p>引用类型：Object</p><a id="more"></a><p>基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。</p><p>引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。</p><p>鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型，对于这个问题，JavaScript 也提供了多种技术方案，但遗憾的是，不同的方案得到的结果也参差不齐。</p><p>下面介绍常用的 4 种方案，并对各个方案存在的问题进行简单的分析。</p><h3 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1. typeof"></a>1. typeof</h3><p>typeof 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：number、boolean、symbol、string、object、undefined、function 等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">''</span>; <span class="comment">// string 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">// number 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(); <span class="comment">// symbol 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">//boolean 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">//undefined 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> [] ; <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Function</span>(); <span class="comment">// function 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(); <span class="comment">//object 无效</span></span><br></pre></td></tr></table></figure><p>有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值：</p><ul><li>对于基本类型，除 null 以外，均可以返回正确的结果。</li><li>对于引用类型，除 function 以外，一律返回 object 类型。</li><li>对于 null ，返回 object 类型。</li><li>对于 function 返回  function 类型。</li></ul><p>其中，null 有属于自己的数据类型 Null ，引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，其实返回object也没有错，因为所有对象的原型链最终都指向了Object，Object是所有对象的”祖宗”。 但当我们需要知道某个对象的具体类型时，typeof 返回的显然不是我们想要的结果。</p><h3 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2. instanceof"></a>2. instanceof</h3><p>instanceof 是用来判断 A 是否为 B 的实例对，表达式为：A instanceof B，如果A是B的实例，则返回true,否则返回false。 在这里需要特别注意的是：<code>instanceof检测的是原型</code>，我们用一段伪代码来模拟其内部执行过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">instanceof</span> (A,B) = &#123;</span><br><span class="line">    <span class="keyword">var</span> L = A.__proto__;</span><br><span class="line">    <span class="keyword">var</span> R = B.prototype;</span><br><span class="line">    <span class="keyword">if</span>(L === R) &#123;</span><br><span class="line">        <span class="comment">//A的内部属性__proto__指向B的原型对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述过程可以看出，当 A 的 <strong>proto</strong> 指向 B 的 prototype 时，就认为A就是B的实例，我们再来看几个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Date</span>;<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">new</span> Person() <span class="keyword">instanceof</span> Person;</span><br><span class="line"></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> Person <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>我们发现，虽然 instanceof 能够判断出 [] 是Array的实例，但它认为 [] 也是Object的实例，为什么呢？</p><p>我们来分析一下[]、Array、Object 三者之间的关系:</p><p>从instanceof 能够判断出 [].<strong>proto</strong> 指向 Array.prototype， 而 Array.prototype.<strong>proto</strong> 又指向了Object.prototype，Object.prototype.<strong>proto</strong> 指向了null,标志着原型链的结束。因此，[]、Array、Object就形成了如下图所示的一条原型链：</p><p><img src="https://lrtwjhs.github.io/img/blog_post_20161211_01.png" alt="prototype"></p><p>从原型链可以看出，[] 的 <strong>proto</strong>  直接指向Array.prototype, 间接指向Object.prototype, 所以按照 instanceof 的判断规则，[] 就是Object的实例。当然，类似的new Date()、new Person() 也会形成这样一条原型链，因此，<code>instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型</code>。</p><p>instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。</p><p>为了解决这个问题， ECMAScript 5 新增了 Array.isArray() 方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。这个方法的用法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">   <span class="comment">//对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持 Array.isArray()方法的浏览器有 IE9+、 Firefox 4+、 Safari 5+、 Opera 10.5+和 Chrome。</p><h3 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3. constructor"></a>3. constructor</h3><p>当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后再在 prototype上添加一个 constructor 属性，并让其指向 F 的引用。如下所示：</p><p><img src="https://lrtwjhs.github.io/img/blog_post_20170817_01.png" alt="constructor img 1"></p><p>当执行 var f = new F() 时，F 被当成了构造函数，f 是F的实例对象，此时 F 原型上的 constructor 传递到了 f 上，因此 f.constructor == F</p><p><img src="https://lrtwjhs.github.io/img/blog_post_20170817_02.png" alt="constructor img 1"></p><p>可以看出，F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。</p><p>同样，JavaScript 中的内置对象在内部构建时也是这样做的：</p><p><img src="https://lrtwjhs.github.io/img/blog_post_20170817_03.png" alt="constructor img 1"></p><p>细节问题：</p><ul><li>null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断</li><li>函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object</li></ul><p><img src="https://lrtwjhs.github.io/img/blog_post_20170817_04.png" alt="constructor img 1"></p><p>为什么变成了 Object？</p><p>因为 prototype 被重新赋值的是一个 { }， { } 是 new Object() 的字面量，因此 new Object() 会将 Object 原型上的 constructor 传递给 { }，也就是 Object 本身。</p><p>因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。</p><h3 id="4-Object-prototype-toString"><a href="#4-Object-prototype-toString" class="headerlink" title="4. Object.prototype.toString"></a>4. Object.prototype.toString</h3><p>toString是Object原型对象上的一个方法，使用 call 来调用该方法会返回调用者的类型字符串，格式为 [object,xxx]，xxx 是调用者的数据类型，其中包括：String,Number,Boolean,Undefined,Null,Function,Date,Array,RegExp,Error,HTMLDocument等，基本上，所有对象的类型都可以通过这个方法获取到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">''</span>) ;   <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) ;    <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) ; <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()); <span class="comment">//[object Symbol]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) ; <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) ; <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Function</span>()) ; <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) ; <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) ; <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>()) ; <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Error</span>()) ; <span class="comment">// [object Error]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>) ; <span class="comment">// [object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>) ; <span class="comment">//[object global] window是全局对象global的引用</span></span><br></pre></td></tr></table></figure><p>需要注意的是，必须通过 call 或 apply 来调用，而不能直接调用 toString ，从原型链的角度讲，所有对象的原型链最终都指向了 Object , 按照JS变量查找规则，其他对象应该也可以直接访问到 Object 的 toString 方法，而事实上，大部分的对象都实现了自身的 toString 方法，这样就可能会导致 Object 的 toString 被终止查找，因此要用call/apply来强制执行 Object 的 toString 方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 ECMAScript 规范中，共定义了 7 种数据类型，分为 基本类型 和 引用类型 两大类，如下所示：&lt;/p&gt;
&lt;p&gt;基本类型：Null,Undefined,String,Number,Boolean,Symbol(ES6)&lt;/p&gt;
&lt;p&gt;引用类型：Object&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript学习笔记" scheme="https://lrtwjhs.github.io/categories/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端开发" scheme="https://lrtwjhs.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记（一）之 数据类型详解</title>
    <link href="https://lrtwjhs.github.io/2017/08/17/2017-08-17-javascript-datatype/"/>
    <id>https://lrtwjhs.github.io/2017/08/17/2017-08-17-javascript-datatype/</id>
    <published>2017-08-16T16:00:00.000Z</published>
    <updated>2017-08-21T02:29:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 ECMAScript6 规范中，JavaScript中有</p><p>6种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number、Symbol和String;</p><p>1种复杂数据类型（也称为引用数据类型）——Object，Object本质上是由一组无序的名值对组成的。</p><a id="more"></a><p>下面详细介绍一下这 7 种数据类型的一些特性：</p><h3 id="1-Undefined"><a href="#1-Undefined" class="headerlink" title="1. Undefined"></a>1. Undefined</h3><p>该类型只有一个值，即 undefined。 undefined 意为 <code>未定义</code>，即当使用 var 声明了变量但未进行复制时，这个变量的值就是 undefined。undefined 产生的原因有两种：</p><ul><li>访问对象不存在的属性或方法</li><li>声明了变量但从未赋值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1,obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(v1); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.get); <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">typeof</span> v1; <span class="comment">// "undefined"</span></span><br><span class="line"><span class="keyword">typeof</span> v2; <span class="comment">// "undefined"</span></span><br><span class="line"><span class="keyword">typeof</span> obj.get; <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure><h3 id="2-Null"><a href="#2-Null" class="headerlink" title="2. Null"></a>2. Null</h3><p>Null 类型也只有一个值：null ， 表示一个变量中没有包含有效数据。null 在这里意为<code>空值</code>、<code>空对象</code> 的意思，更确切的说，一个被赋值为 null 的变量没有保存有效的数值、字符串、布尔、数组或对象等，可以通过给一个变量赋值为 null 来清空变量中的内容。产生 null 的原因只有一个：即对一个变量显式的赋值为 null 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">//null</span></span><br><span class="line"><span class="keyword">typeof</span> p ; <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure><p>从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值会返回 “object” 的原因，但实际上是 JavaScript 最初实现的一个BUG，后来被ECMAScript沿用下来了，详情参考 <a href="http://2ality.com/2013/10/typeof-null.html" target="_blank" rel="external">The history of typeof null</a></p><p>另外，undefined 值也是派生自 null 值的， 因此 ECMA-262 规定对他们的相等测试要返回 true：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span>; <span class="comment">//true</span></span><br><span class="line"><span class="literal">undefined</span> === <span class="literal">null</span>; <span class="comment">//false  不是同一类型</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="number">0</span>; <span class="comment">//false;</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span>; <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="3-Boolean"><a href="#3-Boolean" class="headerlink" title="3. Boolean"></a>3. Boolean</h3><p>Boolean类型只有两个字面值：true 和 false 。 但在 JavaScript 中，所有类型的值都可以转化为与 Boolean 等价的值，转化规则如下：</p><ul><li>所有对象都被当作 true，</li><li>当字符串为空时，该字符串被当作 false</li><li>null 和 undefined 被当作 false</li><li>当数字为 0 时，该数字被当作 false</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// "boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span>; <span class="comment">// "boolean"</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Object</span>()); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">''</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">100</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>需要注意的是，平时我们看到的if(1) {…} ，实际上JS 引擎在内部也对这些值做了 Boolean 转化然后再进行运算的。</p><h3 id="4-Number"><a href="#4-Number" class="headerlink" title="4. Number"></a>4. Number</h3><p>在 Javascript 中，没有 int 和 float 数据类型，而是用 Number 来表示整数和浮点数值，除此之外，Number 还有一个特殊的数值，即NaN (Not a Number)，NaN表示一个承诺返回数值类型数据但实际没有返回的情况。NaN有两个特点：<code>一是任何涉及NaN的操作都会返回NaN，二是NaN不与任何数值相等，包括自己，</code>但可以通过 isNaN() 方法来判断一个数值是否为 NaN ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123.45</span> <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// "number"</span></span><br><span class="line"><span class="literal">NaN</span>+<span class="number">1</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> == <span class="literal">false</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>; <span class="comment">//false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>+<span class="number">1</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="5-Symbol"><a href="#5-Symbol" class="headerlink" title="5. Symbol"></a>5. Symbol</h3><p>Symbol 是 ES6 新增的一种原始数据类型，表示独一无二的值，Symbol 值通过函数生成，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>(); <span class="comment">//s是独一无二的值</span></span><br><span class="line"><span class="keyword">typeof</span> s ; <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure><h3 id="6-String"><a href="#6-String" class="headerlink" title="6. String"></a>6. String</h3><p>String 类型用于表示由零或多个 16 位 Unicode 字符组成的字符序列，即字符串。JavaScript 的字符串类型用于表示文本数据。它是一组16位的无符号整数值的“元素”。在字符串中的每个元素占据了字符串的位置。第一个元素的索引为0，下一个是索引1，依此类推。字符串的长度是它的元素的数量。</p><p>不同于类 C 语言，JavaScript 字符串是不可更改的。这意味着字符串一旦被创建，就不能被修改。但是，可以基于对原始字符串的操作来创建新的字符串。例如：</p><ul><li>获取一个字符串的子串可通过选择个别字母或者使用 String.substr().</li><li>两个字符串的连接使用连接操作符 (+) 或者 String.concat().</li></ul><p>在 JavaScript 中，字符串是基本数据类型，本身不存任何操作方法，为了方便的对字符串进行操作，ECMAScript 提供了一个基本包装类型：String 。它是一种特殊的引用类型，每当读取一个字符串的时候，JS内部就会创建一个对应的 String 对象，这样就可以直接调用 String 上的方法来操作字符串 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substr(<span class="number">2</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，JS内部会自动完成下列处理：</p><ul><li>创建 String 类型的一个实例</li><li>在实例上调用指定的方法</li><li>销毁这个实例</li></ul><p>用伪代码模拟以上三个步骤：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建 s1 的包装对象</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"some text"</span>);</span><br><span class="line"><span class="comment">//调用 s1 上的 substr 方法</span></span><br><span class="line"><span class="keyword">var</span> s2 = s1.substr(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//销毁 s1</span></span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>从中可以看出，基本包装类型 和 引用类型 有一个很重要的区别，即<code>对象的生存期</code>不同 。使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。在 JavaScript 中，类似的基本包装类型还有 Number、Boolean 等。</p><h3 id="7-Object"><a href="#7-Object" class="headerlink" title="7. Object"></a>7. Object</h3><p>除过上面的 6 种基本数据类型外，剩下的就是引用类型了，统称为 Object 类型。细分的话，包括有：Object 类型、Array 类型、Date 类型、RegExp 类型、Function 类型 等，这些对象在JS中都属于引用类型，除 Function 之外，通过 typeof 检测其数据类型返回的都是 object，如果要判断对应的具体类型，则可以通过 Object.prototype.toString 来获取。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"><span class="keyword">var</span> c = [];</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> e = <span class="keyword">new</span> <span class="built_in">RegExp</span>();</span><br><span class="line"><span class="keyword">typeof</span> a;  <span class="comment">//object  有效</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(a); <span class="comment">//[object Object]</span></span><br><span class="line"><span class="keyword">typeof</span> b;  <span class="comment">//function 有效</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(b); <span class="comment">//[object Object]</span></span><br><span class="line"><span class="keyword">typeof</span> c;  <span class="comment">//object 无效</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(c);<span class="comment">//[object Array]</span></span><br><span class="line"><span class="keyword">typeof</span> d;  <span class="comment">//object 无效</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(d);<span class="comment">//[object Date]</span></span><br><span class="line"><span class="keyword">typeof</span> e;  <span class="comment">//object 无效</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(e);<span class="comment">//[object RegExp]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 ECMAScript6 规范中，JavaScript中有&lt;/p&gt;
&lt;p&gt;6种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number、Symbol和String;&lt;/p&gt;
&lt;p&gt;1种复杂数据类型（也称为引用数据类型）——Object，Object本质上是由一组无序的名值对组成的。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript学习笔记" scheme="https://lrtwjhs.github.io/categories/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端开发" scheme="https://lrtwjhs.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>PAT-Advanced 1001. A+B Format (20)</title>
    <link href="https://lrtwjhs.github.io/2016/09/25/2016-09-25-pat-advanced-1001/"/>
    <id>https://lrtwjhs.github.io/2016/09/25/2016-09-25-pat-advanced-1001/</id>
    <published>2016-09-24T16:00:00.000Z</published>
    <updated>2020-12-24T14:42:34.188Z</updated>
    
    <content type="html"><![CDATA[<p>Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p><a id="more"></a><p><strong>Input</strong></p><p>Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space.</p><p><strong>Output</strong></p><p>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.</p><p><strong>Sample Input</strong></p><p>-1000000 9</p><p><strong>Sample Output</strong></p><p>-999,991</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br><span class="line">  c = a + b;</span><br><span class="line">  <span class="keyword">if</span>(c &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    c = -c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c &gt;= MAX) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%03d,%03d\n"</span>,c/MAX,c/<span class="number">1000</span>%<span class="number">1000</span>,c%<span class="number">1000</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c &gt;= <span class="number">1000</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%03d\n"</span>,c/<span class="number">1000</span>,c%<span class="number">1000</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://lrtwjhs.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PAT-Advanced" scheme="https://lrtwjhs.github.io/tags/PAT-Advanced/"/>
    
  </entry>
  
  <entry>
    <title>PAT-Basic 1010. 一元多项式求导 (25)</title>
    <link href="https://lrtwjhs.github.io/2016/09/23/2016-09-23-pat-basic-1010/"/>
    <id>https://lrtwjhs.github.io/2016/09/23/2016-09-23-pat-basic-1010/</id>
    <published>2016-09-22T16:00:00.000Z</published>
    <updated>2020-12-24T14:41:33.876Z</updated>
    
    <content type="html"><![CDATA[<p>设计函数求一元多项式的导数。（注：x^n（n为整数）的一阶导数为n*x^(n-1)。）</p><a id="more"></a><p><strong>输入格式：</strong>以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p><p><strong>输出格式：</strong>以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是0，但是表示为“0 0”。</p><p><strong>输入样例：</strong></p><p>3 4 -5 2 6 1 -2 0</p><p><strong>输出样例：</strong></p><p>12 3 -10 1 6 0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, e, flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;e) != EOF) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n*e)&#123;</span><br><span class="line">      <span class="keyword">if</span>(flag)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         flag = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, n*e, e<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!flag)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"0 0"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计函数求一元多项式的导数。（注：x^n（n为整数）的一阶导数为n*x^(n-1)。）&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://lrtwjhs.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PAT-Basic" scheme="https://lrtwjhs.github.io/tags/PAT-Basic/"/>
    
  </entry>
  
  <entry>
    <title>PAT-Basic 1011. A+B和C (15)</title>
    <link href="https://lrtwjhs.github.io/2016/09/23/2016-09-23-pat-basic-1011/"/>
    <id>https://lrtwjhs.github.io/2016/09/23/2016-09-23-pat-basic-1011/</id>
    <published>2016-09-22T16:00:00.000Z</published>
    <updated>2020-12-24T14:41:48.893Z</updated>
    
    <content type="html"><![CDATA[<p>给定区间[-2^31, 2^31]内的3个整数A、B和C，请判断A+B是否大于C。</p><a id="more"></a><p><strong>输入格式：</strong></p><p>输入第1行给出正整数T(&lt;=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。</p><p><strong>输出格式：</strong></p><p>对每组测试用例，在一行中输出“Case #X: true”如果A+B&gt;C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。</p><p><strong>输入样例：</strong></p><p>4<br><br>1 2 3<br><br>2 3 4<br><br>2147483647 0 2147483646<br><br>0 -2147483648 -2147483647<br></p><p><strong>输出样例：</strong></p><p>Case #1: false<br><br>Case #2: true<br><br>Case #3: true<br><br>Case #4: false<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,n;</span><br><span class="line">  <span class="keyword">long</span> a,b,c;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%ld%ld%ld"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="keyword">if</span>(a+b&gt;c)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: true\n"</span>,i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: false\n"</span>,i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定区间[-2^31, 2^31]内的3个整数A、B和C，请判断A+B是否大于C。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://lrtwjhs.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PAT-Basic" scheme="https://lrtwjhs.github.io/tags/PAT-Basic/"/>
    
  </entry>
  
  <entry>
    <title>PAT-Basic 1012. 数字分类 (25)</title>
    <link href="https://lrtwjhs.github.io/2016/09/23/2016-09-23-pat-basic-1012/"/>
    <id>https://lrtwjhs.github.io/2016/09/23/2016-09-23-pat-basic-1012/</id>
    <published>2016-09-22T16:00:00.000Z</published>
    <updated>2020-12-24T14:42:15.229Z</updated>
    
    <content type="html"><![CDATA[<p>给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字：</p><ul><li>A1 = 能被5整除的数字中所有偶数的和；</li><li>A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4…；</li><li>A3 = 被5除后余2的数字的个数；</li><li>A4 = 被5除后余3的数字的平均数，精确到小数点后1位；</li><li>A5 = 被5除后余4的数字中最大数字。</li></ul><a id="more"></a><p><strong>输入格式：</strong></p><p>每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N，随后给出N个不超过1000的待分类的正整数。数字间以空格分隔。</p><p><strong>输出格式：</strong></p><p>对给定的N个正整数，按题目要求计算A1~A5并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。</p><p>若其中某一类数字不存在，则在相应位置输出“N”。</p><p><strong>输入样例1：</strong></p><p>13 1 2 3 4 5 6 7 8 9 10 20 16 18</p><p><strong>输出样例1：</strong></p><p>30 11 2 9.7 9</p><p><strong>输入样例2：</strong></p><p>8 1 2 4 5 6 7 9 16</p><p><strong>输出样例2：</strong></p><p>N 11 2 N 9</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">//按题目要求，求余判断是哪种情况</span></span><br><span class="line">  <span class="keyword">int</span> n,reminder;</span><br><span class="line">  <span class="keyword">int</span> input[N];</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> A1 = <span class="number">0</span>,A2 = <span class="number">0</span>,A3 = <span class="number">0</span>,A5 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> average = <span class="number">0</span>,t = <span class="number">0</span>;<span class="comment">//(-1)^t交错和幂</span></span><br><span class="line">  <span class="keyword">float</span> A4 = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">  <span class="comment">//输入数据</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;input[i]);</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//数字分类</span></span><br><span class="line">  <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">    reminder = input[i] % <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">switch</span> (reminder) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="comment">//A1 = 能被5整除的数字中所有偶数的和</span></span><br><span class="line">         <span class="keyword">if</span>(!(input[i]%<span class="number">2</span>))</span><br><span class="line">            A1 = A1 + input[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="comment">//A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4...</span></span><br><span class="line">         A2 = A2 + <span class="built_in">pow</span>(<span class="number">-1</span>,t)*input[i];</span><br><span class="line">         t++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="comment">//A3 = 被5除后余2的数字的个数</span></span><br><span class="line">         A3++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="comment">//A4 = 被5除后余3的数字的平均数，精确到小数点后1位</span></span><br><span class="line">         A4 = A4 + input[i];</span><br><span class="line">         average++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="comment">// A5 = 被5除后余4的数字中最大数字</span></span><br><span class="line">          <span class="keyword">if</span>(A5 &lt; input[i])</span><br><span class="line">             A5 =  input[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//输入控制</span></span><br><span class="line">  <span class="keyword">if</span>(A1 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,A1);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"N "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这里的判断条件不能使用A2&gt;2,因为交错和有可能为0</span></span><br><span class="line">  <span class="keyword">if</span>(t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,A2);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"N "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(A3 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,A3);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"N "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(A4 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1lf "</span>,A4/average);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"N "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(A5 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,A5);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"N"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A1 = 能被5整除的数字中所有偶数的和；&lt;/li&gt;
&lt;li&gt;A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4…；&lt;/li&gt;
&lt;li&gt;A3 = 被5除后余2的数字的个数；&lt;/li&gt;
&lt;li&gt;A4 = 被5除后余3的数字的平均数，精确到小数点后1位；&lt;/li&gt;
&lt;li&gt;A5 = 被5除后余4的数字中最大数字。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="算法" scheme="https://lrtwjhs.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="PAT-Basic" scheme="https://lrtwjhs.github.io/tags/PAT-Basic/"/>
    
  </entry>
  
</feed>
